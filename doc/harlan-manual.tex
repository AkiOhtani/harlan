\documentclass[oneside]{report}
\usepackage{listings,color,textcomp}
\usepackage{url}
\usepackage{graphicx}

\begin{document}

\lstset{
  language=Scheme,
  morekeywords= {
    extern, kernel, reduce, vector, void, int, u64, float, str,
    print, module, return, for, while, vector-set!, vector-ref,
    length, iota, vec
  }
}

\title{Harlan User's Guide}

\maketitle

\tableofcontents

\chapter{Getting Started}

Harlan is known to build and run on the following operating systems.
\begin{itemize}
\item Mac OS X 10.6 (Snow Leopard)
\item Mac OS X 10.7 (Lion)
\item Gentoo Linux
\end{itemize}

Others will probably work as well.

Harlan requires an OpenCL implementation as well as Chez Scheme or
Petite Chez Scheme. Below are several OpenCL implementations that
should work.

\begin{itemize}
\item Intel OpenCL SDK
  \footnote{\url{http://software.intel.com/en-us/articles/opencl-sdk/}}
\item NVIDIA CUDA Toolkit
  \footnote{\url{http://developer.nvidia.com/cuda-toolkit}}
\item AMD Accelerated Parallel Processing (APP) SDK
  \footnote{\url{http://developer.amd.com/SDKS/AMDAPPSDK/Pages/default.aspx}}
\end{itemize}

Petite Cheze Scheme can be downloaded from
\url{http://www.scheme.com}.

Once all the prerequisites are installed, you can now build
Harlan. The source code for Harlan is hosted on Indiana University's
private GitHub. The following commands will check out the source code,
build Harlan, and run the test suite.

\begin{verbatim}
    git clone git://github.iu.edu/eholk/harlan.git
    cd harlan
    make check
\end{verbatim}

If the tests are successful, you will see the following at the end of
all the output.

\begin{verbatim}
    All tests succeeded.
\end{verbatim}

The test programs are available in the \texttt{test}
directory. End-to-end test programs have the \texttt{.kfc}
extension. Other extensions represent code that is valid at various
intermediate passes in the compiler.

Make puts test binaries in the \texttt{test.bin} directory, and also
saves output from test programs here. Programs may be run directly
from this directory for easier debugging.

Harlan programs can be compiled manually as follows.

\begin{verbatim}
    ./harlanc hello.kfc
\end{verbatim}

For debugging purposes, the \texttt{-v} flag can be used.

\begin{verbatim}
    ./harlanc -v hello.kfc
\end{verbatim}

This causes the compiler to write out the intermediate results from
each compiler pass.

If \texttt{harlanc} is successful, the compiler will produce an
executable based on the input filename. This program can be run just
like any other program.

If Latex is installed, you can build the Harlan User's Guide (which
you are currently reading) as follows.

\begin{verbatim}
    make docs
\end{verbatim}


%\chapter{Using the Harlan Compiler}

\chapter{The Harlan Language}

Harlan is a language for data parallel computing that has its roots in
C and Scheme. Programs resemble Scheme programs, but several forms
have been added to support parallel processing. One key difference is
that Harlan is statically typed. The compiler infers the type for each
expression, however, so the programmer is not burdened by type
annotations.

\section{Basics}

The traditional Hello, World! program is written as follows.

\begin{lstlisting}
(module
  (define (main)
    (print "Hello, World!")
    (return 0)))
\end{lstlisting}

This program demonstrates several characteristics of Harlan. All
programs exist within a top-level \lstinline{module} form. Harlan
modules contain a number of top-level definitions. The
\lstinline{(define (main) ...)} form defines a function called
\lstinline{main}, which is the entry point to a Harlan program.

The \lstinline{print} form is used to print any value to standard
out. In this program, it will cause the phrase ``Hello, World!'' to be
printed to the terminal. Finally, \lstinline{(return 0)} passes the
value of 0 to the calling function, which is the C convention for
indicating a successful program run.

Programs can contain multiple procedures, and procedures can take
arguments:

\begin{lstlisting}
(module
  (define (add x y)
    (return (+ x y)))

  (define (main)
    (print (add 2 3))
    (return 0)))
\end{lstlisting}

This program prints the value 5 to the terminal and then exits
successfully.

Harlan supports a number of different data types, such as integers,
floating point numbers and strings. A critical component for data
parallelism is the \lstinline{vector} type. Vectors are collections of
data of a certain type. Each element must have the same type. Vectors
can contain other vectors, but since the length of a vector is
considered part of its type, only rectangle shapes are
allowed. Vectors are created as follows.

\begin{lstlisting}
(module
  (define (main)
    (let ((x (vector 1 2)))
      (return 0))))
\end{lstlisting}

This program also demonstrates the \lstinline{let} form, which behaves
like the usual Scheme let.

Vectors can also be nested:

\begin{lstlisting}
(module
  (define (main)
    (let ((x (vector
              (vector 1 2)
              (vector 3 4))))
      (return 0))))
\end{lstlisting}

Harlan supports several vector manipulation forms. These include
\lstinline{vector-ref} and \lstinline{vector-set!}, which behave like
their Scheme equivalents. There is also \lstinline{length}, which
gives the length of a vector. The following program uses these forms
to copy the vector \lstinline{x} to \lstinline{y}.

\begin{lstlisting}
(module
  (define (main)
    (let ((x (vector 1 2))
          (y (vector 0 0)))
      (for (i 0 (length x))
        (vector-set! y i (vector-ref x i)))
      (return 0))))
\end{lstlisting}

This program also introduces the \lstinline{for} loop. For loops have
the following form.

\begin{lstlisting}
  (for (<var> <start> <end>) <body>)
\end{lstlisting}

For loops bind the variable \lstinline{<var>} and executes
\lstinline{<body>} with the loop variable set to each value in the
range from \lstinline{<start>} up to but not including
\lstinline{<end>}.

These vector examples so far have not been terribly interesting, since
they do not display anything to the user. Fortunately, the Harlan
runtime library provides \lstinline{print_2x2_int_vec} to help with
this. You can include this function in your program using a new
top-level declaration called \lstinline{extern}.

\begin{lstlisting}
(module
  (extern print_2x2_int_vec ((vec (vec int 2) 2)) -> void)
  
  (define (main)
    (let ((x (vector
              (vector 1 2)
              (vector 3 4))))
      (print_2x2_int_vec x)
      (return 0))))
\end{lstlisting}

The \lstinline{extern} form takes the name of a procedure, as well as
a type signature for it. The type signature is necessary because the
runtime library is written in C++ and Harlan needs to know the
corresponding type. The declaration above states that
\lstinline{print_2x2_inc_vec} takes a $2 \times 2$ vector of integers
and returns no value. This program executes and produces the following result.

\begin{verbatim}
[ 1 2 ]
[ 3 4 ]
\end{verbatim}

\section{Data Parallelism}

Harlan supports data parallelism through two forms: \lstinline{kernel}
and \lstinline{reduce}. Kernels most naturally correspond to GPU
kernel functions from CUDA or OpenCL. The reduce operator, on the
other hand, is used to combine multiple values into a single
one. Kernels are written as follows:

\begin{lstlisting}
(let ((xs (vector 1 2 3 4)))
  (kernel ((x xs))
    (+ x 1)))
\end{lstlisting}

The kernel block takes a list of bindings followed by an
expression. In this example, the binding \lstinline{(x xs)} states
that \lstinline{x} ranges over the values in the vector
\lstinline{xs}. For each value of \lstinline{x}, the kernel returns
the value of \lstinline{x} plus one. The result of the kernel
expression is a vector containing 2, 3, 4 and 5.

Kernels are allowed to refer to free variables. For example, the
previous example can be written like this:

\begin{lstlisting}
(let ((xs (vector 1 2 3 4)))
  (kernel ((i (iota 4)))
    (+ (vector-ref xs i) 1)))
\end{lstlisting}

Here, \lstinline{(iota 4)} expands into the vector containing 0, 1, 2
and 3. The kernel expression evaluates to the same thing, but the
vector references are now explicit.

Kernels can also be nested.

\begin{lstlisting}
(kernel ((a (vector 2 3)))
  (kernel ((b (vector 5 7)))
    (* a b)))  
\end{lstlisting}

This expresion computes the outer product of \lstinline{(vector 2 3)}
and \lstinline{(vector 5 7)}. If we print the result, we see we get
the expected value:

\begin{verbatim}
[ 10 14 ]
[ 15 21 ]
\end{verbatim}

The other data parallel operator in Harlan is the \lstinline{reduce}
operator. This is used to combine a vector of values into a single
value. Below is a simple example.

\begin{lstlisting}
(reduce + (vector 1 1 1 1))  
\end{lstlisting}

This expression combines all the values in its vector using the
addition operator. The expression evaluates to 4.

Reduce can be used to calculate a dot product as follows.

\begin{lstlisting}
(reduce + (kernel ((x xs) (y ys))
            (* x y)))
\end{lstlisting}

\section{Example: The Mandelbrot Set}

Below is a program that calculates the Mandelbrot set and writes it to
a file.  Running this program produces the image in Figure
\ref{fig:mandelbrot}.

\begin{lstlisting}
(module
  (extern write_pgm (str (vec (vec int 1024) 1024)) -> void)
  (extern nanotime () -> u64)
  
  (fn main ()
    (let start (nanotime))
    (let img (kernel ((i (iota 1024)))
               (kernel ((j (iota 1024)))
                 (let ((cr (- (/ (int->float j) 512.0) 1.5))
                       (ci (- (/ (int->float i) 512.0) 1.0))
                       (xr 0.0)
                       (xi 0.0)
                       (idx 0)
                       (escape 0))
                   (while (< idx 256)
                     (let ((xrp (+ (- (* xr xr) (* xi xi)) cr))
                           (xip (+ (* 2.0 (* xr xi)) ci)))
                       (set! xr xrp)
                       (set! xi xip)
                       (let m (+ (* xr xr) (* xi xi)))
                       (if (< m 4.0)
                           (set! escape (- idx 1)))
                       (set! idx (+ idx 1))))
                   escape))))
    (let stop (nanotime))
    (write_pgm "test.bin/mandelbrot.pgm" img)
    (print "Time to generate Mandelbrot Set in milliseconds:")
    (print (/ (- stop start) 1000000))
    (return 0)))  
\end{lstlisting}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{figures/mandelbrot.eps}
  \caption{The Mandelbrot Set, as generated by a Harlan program.}
  \label{fig:mandelbrot}
\end{figure}

\chapter{The Runtime Library}

Harlan provides a small library of built-in functions. These are
described in this chapter. Each of these may be used in a program by
adding the appropriate \lstinline{extern} definition.

\section{nanotime}

\textbf{Prototype:} \lstinline{(extern nanotime () -> u64)}

This function returns the number of nanoseconds that has elapsed since
January 1, 1970. It is useful for timing benchmark programs.

\section{print\_2x2\_int\_vec}

\textbf{Prototype:} \lstinline{(extern print_2x2_int_vec ((vec (vec int 2) 2)) -> void)}

Formats a $2 \times 2$ matrix and prints it to standard out.

% TODO: include example output

\section{write\_pgm}

\textbf{Prototype:} \lstinline{(extern write_pgm (str (vec (vec int 1024) 1024)) -> void)}

This function treats its second argument as a $1024 \times 1024$
grayscale image and writes it to a Portable GrayMap (PGM) file named
by the function's string argument. Each entry in the image should be
between 0 and 255, inclusive. The resulting file may then be viewed by
a program such as ToyViewer on the Mac.

This function is used by the Mandelbrot set test cases to allow us to
visually confirm the program is behaving correctly.

\end{document}
