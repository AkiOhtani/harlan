;; Dense dot product between two vectors.

;; This version compares sequential reduction on the CPU to a
;; hand-coded logarithmic reduction.

(%testspec
 (%tags bench))

(module
  (extern nanotime () -> u64)

  (define (my_make_vector len val)
    (kernel ((i (iota len))) val))

  ;; Recursive with cutoff
  ;;(define (vector_sum xs)
  ;;  (if (<= (length xs) 1024)
  ;;      (reduce + xs)
  ;;      (let ((len (/ (length xs) 2)))
  ;;        (vector_sum
  ;;         (kernel ((i (iota len)))
  ;;           (+ (vector-ref xs i)
  ;;              (vector-ref xs (+ i len))))))))
  
  ;; Recursive algorithm
  (define (vector_sum xs)
    (if (= (length xs) 1)
        (vector-ref xs 0)
        (let ((len (/ (length xs) 2)))
          (let ((temp_sum (vector_sum
                           (kernel ((i (iota len)))
                             (+ (vector-ref xs i)
                                (vector-ref xs (+ i len)))))))
            (if (= 1 (mod (length xs) 2))
                (+ (vector-ref xs (- (length xs) 1))
                   temp_sum)
                temp_sum)))))

  ;; Iterative algorithm
  ;;(define (vector_sum xs)
  ;;  (let ((len (/ (length xs) 2)))
  ;;    (while (> (length xs) 1)
  ;;      ;;(print "vector_sum length = ");
  ;;      ;;(print (length xs))
  ;;      ;;(print "\n")
  ;;      (set! xs (kernel ((i (iota len)))
  ;;                   (+ (vector-ref xs i) (vector-ref xs (+ i len)))))
  ;;      (set! len (/ len 2)))
  ;;    (vector-ref xs 0)))
  
  (define (dot X Y)
    (let ((start (nanotime)))
      (let ((dot (reduce + (kernel ((x X) (y Y))
                             (* x y)))))
        (let ((stop (nanotime)))
          ;;(assert (= dot (int->float len)))
          (- stop start)))))

  ;; This one uses vector_sum
  (define (dot2 X Y)
    (let ((start (nanotime)))
      (let ((dot (vector_sum (kernel ((x X) (y Y))
                               (* x y)))))
        (let ((stop (nanotime)))
          ;;(assert (= dot (int->float len)))
          (- stop start)))))
  
  (define (bench_length len)
    (let ((iters 10)
          (ttime 0)
          (ttime2 0)
          (X (my_make_vector len (int->float 1)))
          (Y (my_make_vector len (int->float 1))))
      (for (k 0 iters)
        (set! ttime (+ ttime (dot X Y))))
      (for (k 0 iters)
        (set! ttime2 (+ ttime2 (dot2 X Y))))
      (print len)
      (print "\t")
      (print (/ (/ ttime 1000) iters))
      (print "\t")
      (print (/ (/ ttime2 1000) iters))
      (print "\n")))
  
  (define (main)
    (let ((i 1000000))
      (while (< i 100000000)
        (begin
          (for (j i (* 2 i) (if (> i 16) (/ i 10) 1))
            (bench_length j))
          (set! i (* i 2)))))
    (return 0)))

