;; Dense dot product between two vectors.

;; This version compares sequential reduction on the CPU to a
;; hand-coded logarithmic reduction.

(%testspec
 (%tags bench))

(module
  (extern nanotime () -> u64)

  (define (my_make_vector len val)
    (kernel ((i (iota len))) val))

  (define (vector_sum xs)
    (let ((len (/ (length xs) 2)))
      (while (> (length xs) 1)
        ;;(print "vector_sum length = ");
        ;;(print (length xs))
        ;;(print "\n")
        (set! xs (kernel ((i (iota len)))
                     (+ (vector-ref xs i) (vector-ref xs (+ i len)))))
        (set! len (/ len 2)))
      (vector-ref xs 0)))
  
  (define (dot len)
    (let ((X (my_make_vector len (int->float 1)))
          (Y (my_make_vector len (int->float 1))))
      (let ((start (nanotime)))
        (let ((dot (reduce + (kernel ((x X) (y Y))
                               (* x y)))))
          (let ((stop (nanotime)))
            ;;(assert (= dot (int->float len)))
            (- stop start))))))

  ;; This one uses vector_sum
  (define (dot2 len)
    (let ((X (my_make_vector len (int->float 1)))
          (Y (my_make_vector len (int->float 1))))
      (let ((start (nanotime)))
        (let ((dot (vector_sum (kernel ((x X) (y Y))
                                 (* x y)))))
          (let ((stop (nanotime)))
            ;;(assert (= dot (int->float len)))
            (- stop start))))))
  
  (define (bench_length len)
    (let ((iters 10)
          (ttime 0)
          (ttime2 0))
      (for (k 0 iters)
        (set! ttime (+ ttime (dot len))))
      (for (k 0 iters)
        (set! ttime2 (+ ttime2 (dot2 len))))
      (print len)
      (print "\t")
      (print (/ (/ ttime 1000) iters))
      (print "\t")
      (print (/ (/ ttime2 1000) iters))
      (print "\n")))
  
  (define (main)
    (let ((i 1))
      (while (< i 100000000)
        (bench_length i)
        (set! i (* i 2))))
    (return 0)))

