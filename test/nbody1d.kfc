;; code for 1 dimensional nbody simulation 
(%testspec (%tags xfail))

(module
  (define (main)
    (let Fx (vector 0 0 0 0 0 0 0 0 0 0 ))
    (let Fy (vector 0 0 0 0 0 0 0 0 0 0 ))
    (let Fz (vector 0 0 0 0 0 0 0 0 0 0 ))
    (let Vx (vector 0 0 0 0 0 0 0 0 0 0 ))
    (let Vy (vector 0 0 0 0 0 0 0 0 0 0 ))
    (let Vz (vector 0 0 0 0 0 0 0 0 0 0 ))
    (let G  0.000000000001)
    ;;(set! G  1)
    ;;for t1 = 1:dT:T
    (for (t1 1 T)
      (for (t2 1 n)
        (let k t2)
        (let tmp (vector-ref Rx k))
        (let drx  (kernel((x Rx))
                    (- x tmp)))
        (let tmp (vector-ref Ry k))
        (let dry  (kernel((y Ry))
                    (- y tmp)))
        (let tmp (vector-ref Rz k))
        (let drz  (kernel((z Rz))
                    (- z tmp)))
        ;;r = drx.*drx + dry.*dry + drz.*drz;
        (let sq_drx (kernel((x drx))
                      (^ x 2)))
        (let sq_dry (kernel((y dry))
                      (^ y 2)))
        (let sq_drz (kernel((z drz))
                      (^ z 2)))
        (let r  (kernel((x sq_drx) (y dry) (z drz))
                  (+ (+ xy) z)))
        (let tmp  (vector-ref m k))
        ;;r(k)  = 1;
        (vector-set! r k  1)
        ;;M = M*m(k);
        (let M  (kernel((m1 m))
                  (* m1 tmp)))
        (vector-set! M k 0)
        ;;f=G*(M./r);
        (let f  (kernel((m M)(r1 r))
                  (* (/ m r1) G )))
        ;;find the unit direction vector
        ;;r = sqrt(r) 
        ;;sqrt() is possibly causing some error; replacing it with some binop
        (let r  (kernel((r1 r))
                  (* r1 r1)))
        ;;
        (let drx  (kernel((d drx)(r1 r))
                    (/ d r1)))
        (let dry  (kernel((d dry)(r1 r))
                    (/ d r1)))
        (let drz  (kernel((d drz)(r1 r))
                    (/ d r1)))
        (let frx  (kernel((f1 f) (f2 frx))
                    (* f1 f2  )))
        (let fry  (kernel((f1 f) (f2 fry))
                    (* f1 f2 )))
        (let frz  (kernel((f1 f) (f2 frz))
                    (* f1 f2 )))
        (let tmp1 (reduce +
                    (kernel((f frx))
                      f)))
        (let tmp2 (reduce +
                    (kernel((f fry))
                      f)))
        (let tmp3 (reduce +
                    (kernel((f frz))
                      f)))
        (vector-set!  Fx k  (/ tmp1 (length frx)))           
        (vector-set!  Fy k  (/ tmp2 (length fry)))           
        (vector-set!  Fz k  (/ tmp3 (length frz)))           
        )
      (let ax (kernel((f Fx)(m1 m))
                (/ f m1))) 
      (let ay (kernel((f Fy)(m1 m))
                (/ f m1))) 
      (let az (kernel((f Fz)(m1 m))
                (/ f m1))) 

      ;;Vx = Vx+ax*dT;
      ;;Vy = Vy+ay*dT;
      ;;Vz = Vz+az*dT;
      
      (let Vx (kernel((v Vx)(a ax))
                (+ (* v dT) a)))
      (let Vy (kernel((v Vy)(a ay))
                (+ (* v dT) a)))
      (let Vz (kernel((v Vz)(a az))
                (+ (* v dT) a)))
      
      
      ;;Rx = Rx+Vx*dT;
      ;;Ry = Ry+Vy*dT;
      ;;Rz = Rz+Vz*dT;

      (let Rx (kernel((v Vx)(a Rx))
                (+ (* v dT) a)))
      (let Ry (kernel((v Vy)(a Ry))
                (+ (* v dT) a)))
      (let Rz (kernel((v Vz)(a Rz))
                (+ (* v dT) a)))
      )
    (return 0)))
