;; -*- scheme -*-

(module
  (fn main ()
      (let A (vector
              (vector 1 2 3 4)
              (vector 1 2 3 4)))
      ;; Ideally we'd dynamically allocate a target with the right
      ;; dimensions.
      (let B (vector
              (vector 0 0)
              (vector 0 0)
              (vector 0 0)
              (vector 0 0)))
      (for (i 0 (length (var A)))
           (let row (vector-ref (var A) (var i)))
           ;; We could probably make this inner loop into a kernel.
           (for (j 0 (length (var row)))
                (vector-set! (vector-ref (var B) (var j))
                             (var i)
                             (vector-ref (var row) (var j)))))
      (print (var B))
      (assert (= 1 (vector-ref (vector-ref (var B) 0) 0)))
      (assert (= 1 (vector-ref (vector-ref (var B) 0) 1)))
      (assert (= 2 (vector-ref (vector-ref (var B) 1) 0)))
      (assert (= 2 (vector-ref (vector-ref (var B) 1) 1)))
      (assert (= 3 (vector-ref (vector-ref (var B) 2) 0)))
      (assert (= 3 (vector-ref (vector-ref (var B) 2) 1)))
      (assert (= 4 (vector-ref (vector-ref (var B) 3) 0)))
      (assert (= 4 (vector-ref (vector-ref (var B) 3) 1)))
      (return 0)))