(library
  (harlan middle annotate-free-vars)
  (export annotate-free-vars)
  (import
   (rnrs)
   (elegant-weapons helpers)
   (elegant-weapons sets))

(define-match annotate-free-vars
  ((module . ,[annotate-decl* -> decl*])
   `(module . ,decl*)))

(define-match annotate-decl*
  (((,tag* ,name* . ,rest*) ...)
   (map (annotate-decl name*)
     `((,tag* ,name* . ,rest*) ...))))

(define-match (annotate-decl globals)
  ((fn ,name ,args ,type ,[annotate-stmt -> stmt fv*])
   (let ((fv* (fold-right remove fv* (append globals args))))
     (if (null? fv*)
         `(fn ,name ,args ,type ,stmt)
         (error 'annotate-free-vars "unbound varaible(s)" fv*))))
  ((extern ,name ,arg-types -> ,type)
   `(extern ,name ,arg-types -> ,type)))

(define-match annotate-stmt
  ((begin ,[stmt* fv**] ...)
   (values `(begin . ,stmt*) (apply union fv**)))
  ((kernel ,dims (((,x* ,t*)
                   (,[annotate-expr -> xs* fv**] ,ts*)
                   ,dim*) ...)
     ,[stmt fv*])
   (let ((fv* (fold-right remove fv* x*)))
     (values
       `(kernel ,dims (((,x* ,t*) (,xs* ,ts*) ,dim*) ...)
          (free-vars . ,fv*) ,stmt)
       (apply union fv* fv**))))
  ((return) (values `(return) '()))
  ((return ,[annotate-expr -> e fv*])
   (values `(return ,e) fv*))
  ((if ,[annotate-expr -> test tfv*] ,[conseq cfv*])
   (values `(if ,test ,conseq) (union tfv* cfv*)))
  ((if ,[annotate-expr -> test tfv*] ,[conseq cfv*] ,[alt afv*])
   (values `(if ,test ,conseq ,alt)
     (union tfv* cfv* afv*)))
  ((do ,[annotate-expr -> e fv*])
   (values `(do ,e) fv*))
  ((let ((,x* ,[annotate-expr -> e* fv**]) ...) ,[stmt fv*])
   (let ((fv* (fold-right remove fv* x*)))
     (values `(let ((,x* ,e*) ...) ,stmt)
       (apply union fv* fv**))))
  ((while ,[annotate-expr -> e efv*] ,[stmt sfv*])
   (values `(while ,e ,stmt) (union efv* sfv*)))
  ((for (,x ,[annotate-expr -> start sfv*]
          ,[annotate-expr -> end efv*])
     ,[stmt bfv*])
   (let ((bfv* (remq x bfv*)))
     (values `(for (,x ,start ,end) ,stmt)
       (union bfv* sfv* efv*))))
  ((set! ,[annotate-expr -> x xfv*] ,[annotate-expr -> e efv*])
   (values `(set! ,x ,e) (union xfv* efv*)))
  ((print ,[annotate-expr -> e fv*])
   (values `(print ,e) fv*))
  ((assert ,[annotate-expr -> e fv*])
   (values `(assert ,e) fv*)))

(define-match annotate-expr
  ((void) (values `(void) '()))
  ((,t ,n) (guard (scalar-type? t)) (values `(,t ,n) '()))
  ((var ,t ,x) (values `(var ,t ,x) `(,x)))
  ((c-expr ,t ,x) (values `(c-expr ,t ,x) `()))
  ((cast ,t ,[e fv*]) (values `(cast ,t ,e) fv*))
  ((call ,[rator fv*] ,[rand* fv**] ...)
   (values
     `(call ,rator . ,rand*)
     (apply union fv* fv**)))
  ((let ((,x* ,[e* fv**]) ...) ,[expr fv*])
   (let ((fv* (fold-right remove fv* x*)))
     (values `(let ((,x* ,e*) ...) ,expr)
       (apply union fv* fv**))))
  ((if ,[test tfv*] ,[conseq cfv*] ,[alt afv*])
   (values `(if ,test ,conseq ,alt)
     (union tfv* cfv* afv*)))
  ((sizeof ,t) (values `(sizeof ,t) '()))
  ((addressof ,[e fv*]) (values `(addressof ,e) fv*))
  ((,op ,[lhs lfv*] ,[rhs rfv*])
   (guard (or (binop? op) (relop? op)))
   (values `(,op ,lhs ,rhs) (union lfv* rfv*)))
  ((vector-ref ,t ,[v vfv*] ,[i ifv*])
   (values `(vector-ref ,t ,v ,i) (union vfv* ifv*))))

;; end library
)
